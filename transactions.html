/*************************************************
 * CONFIG ‚Äî TRANSACTIONS SHEETS
 *************************************************/
const SHEET_TXN      = "Transactions_Raw";
const SHEET_ACCOUNTS = "Masters_Accounts";
const SHEET_CATS     = "Masters_Categories";
const SHEET_SUBCATS  = "Masters_SubCategories";
const SHEET_EMI      = "Masters_EMI";

/*************************************************
 * CONFIG ‚Äî HEALTH SHEET
 *************************************************/
const HEALTH_SHEET_ID   = "1XEDF8vCpMg_9eLqRfFpN9h-PKaIBvIum6Cjc964AGDY";
const HEALTH_SHEET_NAME = "Health_Raw";

/*************************************************
 * üîë SINGLE UNIFIED GET ENTRY POINT
 *************************************************/
function doGet(e) {

  // Health / API heartbeat
  if (!e || !e.parameter || !e.parameter.action) {
    return ContentService
      .createTextOutput(JSON.stringify({
        status: "API Live",
        timestamp: new Date()
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  const action = e.parameter.action;

  switch (action) {

    /* ========= TRANSACTIONS ========= */
    case "accounts":
      return respond(getAccounts());

    case "categories":
      return respond(getCategories());

    case "subcategories":
      return respond(getSubCategories());

    case "emis":
      return respond(getEmis());

    case "recent":
      return respond(getRecentTransactions());

    case "balances":
      return respond(getBalances());

    /* ========= HEALTH ========= */
    case "healthStatus":
      return ContentService
        .createTextOutput(JSON.stringify({
          status: "Health API Live",
          timestamp: new Date()
        }))
        .setMimeType(ContentService.MimeType.JSON);

    default:
      return respond({ error: "Invalid GET action" });
  }
}

/*************************************************
 * üîê SINGLE UNIFIED POST ENTRY POINT
 *************************************************/
function doPost(e) {
  try {
    const body = JSON.parse(e.postData.contents);

    /* ---------- TRANSACTIONS ---------- */
    if (body.action === "addTransaction") {
      return addTransaction(body.payload);
    }

    /* ---------- HEALTH ---------- */
    if (body.action === "addHealth") {
      return addHealthEntry(body.payload);
    }

    return respond({ error: "Invalid POST action" });

  } catch (err) {
    return respond({ error: err.message });
  }
}

/*************************************************
 * ============ TRANSACTIONS LOGIC ============
 *************************************************/
function addTransaction(p) {
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_TXN);

  const txnDateObj = new Date(p.txnDate);
  const mm = String(txnDateObj.getMonth() + 1).padStart(2, "0");
  const dd = String(txnDateObj.getDate()).padStart(2, "0");

  const serial = getNextTxnSerial(txnDateObj);
  const txnId = `TXN-${mm}${dd}${String(serial).padStart(2, "0")}`;

  sh.appendRow([
    txnId,
    new Date(),
    p.txnDate,
    p.txnType,
    p.category,
    p.subCategory || "",
    Number(p.amount),
    p.fromAccount || "",
    p.toAccount || "",
    p.emiId || "",
    p.notes || "",
    p.source || "WEB",
    ""
  ]);

  return respond({ status: "SUCCESS", txnId });
}

function getNextTxnSerial(txnDate) {
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_TXN);
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return 1;

  const target = Utilities.formatDate(txnDate, "Asia/Kolkata", "yyyy-MM-dd");
  const dates = sh.getRange(2, 3, lastRow - 1, 1).getValues();

  let count = 0;
  dates.forEach(r => {
    if (!r[0]) return;
    const d = Utilities.formatDate(new Date(r[0]), "Asia/Kolkata", "yyyy-MM-dd");
    if (d === target) count++;
  });

  return count + 1;
}

function getAccounts()      { return getColumn(SHEET_ACCOUNTS, 2); }
function getCategories()    { return getColumn(SHEET_CATS, 2); }
function getEmis() {
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_EMI);
  const data = sh.getRange(2, 1, sh.getLastRow() - 1, 4).getValues();
  return data.map(r => ({ id: r[0], name: r[1], amount: r[3] }));
}

function getSubCategories() {
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_SUBCATS);
  const data = sh.getRange(2, 2, sh.getLastRow() - 1, 2).getValues();
  const map = {};
  data.forEach(([cat, sub]) => {
    if (!map[cat]) map[cat] = [];
    map[cat].push(sub);
  });
  return map;
}

function getRecentTransactions() {
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_TXN);
  const lastRow = sh.getLastRow();
  const startRow = Math.max(2, lastRow - 9);
  const data = sh.getRange(startRow, 1, lastRow - startRow + 1, 9).getValues();

  return data.reverse().map(r => ({
    date: Utilities.formatDate(new Date(r[2]), "Asia/Kolkata", "dd-MMM"),
    type: r[3],
    category: r[4],
    from: r[7],
    to: r[8],
    amount: r[6]
  }));
}

function getBalances() {
  const sh = SpreadsheetApp.getActive().getSheetByName(SHEET_TXN);
  const data = sh.getRange(2, 1, sh.getLastRow() - 1, 9).getValues();
  const balances = {};

  data.forEach(r => {
    const amt = Number(r[6]) || 0;
    if (r[7]) balances[r[7]] = (balances[r[7]] || 0) - amt;
    if (r[8]) balances[r[8]] = (balances[r[8]] || 0) + amt;
  });

  return Object.keys(balances).map(a => ({
    account: a,
    balance: balances[a].toFixed(2)
  }));
}

/*************************************************
 * ============ HEALTH LOGIC ============
 *************************************************/
function addHealthEntry(data) {
  const lock = LockService.getScriptLock();
  lock.waitLock(10000);

  try {
    const sheet = SpreadsheetApp
      .openById(HEALTH_SHEET_ID)
      .getSheetByName(HEALTH_SHEET_NAME);

    const dates = sheet.getRange(2, 3, sheet.getLastRow(), 1).getValues().flat();
    if (dates.includes(data.entryDate)) {
      return respond({ status: "DUPLICATE" });
    }

    const toMin = t => {
      if (!t) return null;
      const [h, m] = t.split(":").map(Number);
      return h * 60 + m;
    };

    let sleepHours = "";
    if (data.sleepTime && data.wakeTime) {
      let diff = toMin(data.wakeTime) - toMin(data.sleepTime);
      if (diff <= 0) diff += 1440;
      sleepHours = (diff / 60).toFixed(2);
    }

    let workHours = "";
    if (data.workLogin && data.workLogout) {
      const diff = toMin(data.workLogout) - toMin(data.workLogin);
      if (diff > 0) workHours = (diff / 60).toFixed(2);
    }

    const entryId = `HLT-${Utilities.formatDate(new Date(data.entryDate), "Asia/Kolkata", "MMdd")}`;

    sheet.appendRow([
      entryId,
      new Date(),
      data.entryDate,
      data.sleepTime || "",
      data.wakeTime || "",
      sleepHours,
      data.workLogin || "",
      data.workLogout || "",
      workHours,
      data.steps || "",
      data.workoutMin || "",
      data.waterLiters || "",
      data.weightKg || "",
      data.notes || "",
      data.screenTime || "",
      "Web"
    ]);

    return respond({ status: "OK" });

  } finally {
    lock.releaseLock();
  }
}

/*************************************************
 * UTILITIES
 *************************************************/
function getColumn(sheetName, col) {
  const sh = SpreadsheetApp.getActive().getSheetByName(sheetName);
  return sh.getRange(2, col, sh.getLastRow() - 1, 1).getValues().flat().filter(String);
}

function respond(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
